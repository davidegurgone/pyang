# -*- outline -*-
#

This document defines the concept of operational state data in the
context of YANG and the Network Configuration Protocol (NETCONF).  It
updates RFC 6020 with rules for how to model the operational state,
and defines NETCONF operations to retreive and modify the operational
state.

* Introduction

** Terminology

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14, ^RFC2119^.

*** Terms

The following terms are defined in ^RFC6241^ and are not redefined
here:

- client
- datastore
- server

The following terms are defined in ^RFC6020^ and are not redefined
here:

- data model
- schema tree
- data node

The following terms are used within this document:

- operational state data: The data in the operational state datastore.

- operational state datastore: A conceptual data structure from which
  one can determine device state and behavior.

- configuration: A separate overlay/blueprint containing only data
  explicitly specified by a client (all clients?).  A configuration
  schema is congruent to a subtree of OSD schema. However,
  configuration may contain parts that are currently not present in
  OSD (pre-provisioning).

* Objectives

- Develop a general model applicable not only to NETCONF but also
  to other approaches (RESTful, editable state data etc.).
- Develop a specific model for NETCONF and YANG.
- As little changes to NETCONF and YANG as possible.
- Clarification of the terms "operational state data" and "configuration".

* Architecture of the device management system

** Operational State Datastore

The essential component of the device management system described in
this document is the operational state datastore.  It consists of all
parameters that provide information about the instantaneous state of
the device and immediately influences the device's behavior.

The operational state datastore is a conceptual data structure.  This
means that implementations may choose any suitable representation of
the datastore, including dynamically generating it upon request.

Operational state may be modified through one or more management
interface, or through the operation of network protocols.  All such
means of accessing and changing the operational state act conceptually
on the same data - the operational state datastore.  It means, for
instance, that any change caused by a network protocol is immediately
visible to all management interfaces.

** Management Interfaces

Management interfaces provide users and applications with an interface
for viewing and manipulating the operational state datastore.
Examples of management interfaces are NETCONF, SNMP, and the CLI.  A
device may implement multiple management interfaces.

Each management interface has its own rules for reading and writing
the operational state datastore.

Section XXX of this document contains the specification of one
particular management interface - the NETCONF protocol.

* Problem Statement

** Modelling and Retrieving Operational State

The NETCONF operation <get> returns both device state data and the
running configuration.  This implies that any state data must be
modelled separately from the configuration data, leading to
duplication of data models.

This approach has several drawbacks.  It is counter-intuitive to data
model designers, who tend to mix configuration parameters with state
parameters (see ^ex-if-list-1^ for an example).  Data model
duplication is error prone and leads to bigger data models, that are
more difficult to understand.  Further, there is no formal information
in the data model about the relationship between the configuration
data and the operational state data.

*** Example: Interface List @ex-if-list-1@

Suppose we want to model a list of interfaces.  We allow
pre-configuration, i.e., it is legal to configure an interface for
which there is currently no hardware present in the system.  In this
simple example, each interface has a name and a counter of the number
of packets received.  The counter is operational state data.

  list interface {
    key name;

    leaf name { ... }
    leaf in-packets {
      type yang:counter64;
      config false;
    }
    ...
  }

A particular device has hardware for two interfaces; "eth0" and
"eth1".  In the configuration there is:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth2</name>
     ...
   </interface>

We can see this by doing <get-config>.

Operationally, however, the interfaces used are "eth0" and "eth1",
although "eth1" does not have any configuration and does not
send or receive packets.

Now, how can we see "eth1"?  If we use <get> we will get the running
configuration and state data.  So, <get> will not show us "eth1",
since it is not present in the running configuration.

With NETCONF as currently defined, the only alternative is to
duplicate the data model:

    list interface {
      key name;

      leaf name { ...}
      ...
    }

    list interface-oper {
      config false;
      key name;

      leaf name { ...}
      leaf in-packets { ... }
      ...
    }

** Modifying the Operational State

In some cases, it is useful for clients to directly modify the
operational state.  An example of this is the recent discussions
around an Interface to the Routing System (IRS), where a client needs
to modify the routing table, without storing routes in the
configuration.

With NETCONF as currently designed, the only way to do this is to
define separate operations.  This leads to another kind of data model
duplication, where every writable parameter is modelled both as state
data that can be retrieved using the <get> operation, and also as
input parameters to at least one rpc operation.  

*** Example: Routing Table Modification

Suppose we want to model IPv4 routing tables as operational state, and
we also want to be able to let a client modify this data.  We have to
do:

  list routing-table {
    config false;
    key name;

    leaf name { ... }
    list route {
      key id;

      leaf id { ... }
      leaf dest-prefix { ... }
      leaf next-hop { ... }
      ...
    }
  }
  
  rpc add-route {
    input {
      leaf routing-table-name { ... }
      leaf route-id { ... }
      leaf dest-prefix { ... }
      leaf dest-prefix { ... }
      leaf next-gop { ... }
    }
  }
  
  rpc delete-route {
    input {
      leaf routing-table-name { ... }
      leaf route-id { ... }
    }
  }

** Proposed Solution

[NOT FINISHED]


Introduce the idea of "operational" data.  The data model for the
operational data is the entire schema tree, both config true and
config false nodes.  Constraints (mandatory, must etc.) do not apply to
this data.

(We could potentially add a new YANG statement "operational
true/false" which then could be used to mark config true data as NOT
being part of the operational data tree.  Unclear if this is needed
though.)

Introduce a new rpc operation "get-operational", which would return
the operational data tree.

Note that when get-config is used to retrieve a config true node, the
value stored in the data store is returned.  When get-operational is
used to retrieve the same node, the value actually used by the device
is returned.  This value may or may not be the same as the value in
the data store.  For example, an ip address leaf could be received
over DHCP.

Need to figure out the life-cycle / persistency requirements.  Very
unclear how this should work.

*** Alt. 1

Introduce edit-operational.  This modifies the subset of the
operational data tree that is also marked as writable.

Drawback: does not handle persistent operarational data.

If we have persistent operational data, this has to be its own data
store that can be read and written.

A data model w/o the writable markers cannot be written to.  This is a
problem, since it is not obvious that the original designer though
about future use cases.  For example, our route tables are read-only.
Then IRS comes along and wants to write to this data.  Do we have to
update our spec?  Not good.  Obe option is for IRS to publish a
deviation data model that added the writable statement to our model.
This would be backwards compliant and good.  Even better would be if
they could publish a conformance statement in a module, w/o the meed
for deviations.

* YANG Module @module@

RFC Ed.: update the date below with the date of RFC publication and
remove this note.

!! include-figure ietf-netconf-operational.yang extract-to="ietf-netconf-operational.yang"

* IANA Considerations @iana@

This document registers a URI in the IETF XML registry
^RFC3688^. Following the format in RFC 3688, the following
registration is requested to be made.

     URI: urn:ietf:params:xml:ns:yang:ietf-netconf-operational

     Registrant Contact: The NETMOD WG of the IETF.

     XML: N/A, the requested URI is an XML namespace.

This document registers a YANG module in the YANG Module Names
registry ^RFC6020^.

  name:         ietf-netconf-operational
  namespace:    urn:ietf:params:xml:ns:yang:ietf-netconf-operational
  prefix:       oper
  reference:    RFC XXXX

* Security Considerations

TBD

*! start-appendix

*** Example: Interface List @ex-if-list-2@

With the proposed solution, the interface list example from
^ex-if-list-2, can be solved with a single list:

  list interface {
    key name;

    leaf name { ... }
    leaf in-packets {
      type yang:counter64;
      config false;
    }
    ...
  }

The operation <get-operational> will return the interfaces available
on the device:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth1</name>
     ...
   </interface>

And <get-config> on running will return the configured interfaces,
just as before:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth2</name>
     ...
   </interface>

* Example: Interface Speed

A typical problem is when the value space for the configuration data
is a superset of the value space for the operational state data.  An
example of this is Ethernet duplex, which can be configured as "half",
"full", or "auto", but the operationally used value is either "half"
or "full".  Without the definition of operational state in this
document, this would have to be modelled as two separate leafs:

  leaf duplex {
    type enumeration {
      enum "half";
      enum "full";
      enum "auto";
    }
  }
  
  leaf oper-duplex {
    type enumeration {
      enum "half";
      enum "full";
    }
  }

With the solution defined in this document, a single leaf is
sufficient:

  leaf duplex {
    type enumeration {
      enum "half";
      enum "full";
      enum "auto";
    }
  }

* Example: Admin vs. Oper State

Another common problem is when the value space for the configured data
is a subset of the operarational state data.  An example is an
interface's desired state, and its operational state.  The desired
state can be "up" or "down", but the operational state can be "up",
"lower-layer-down", "testing", etc.

These kind of situations are still best modelled as two separate
leafs, one "admin-state" and one "oper-state".


* Old Ideas

[REMOVE THIS SECTION]

Introduce the idea of control data.  This would be a separate data
tree.  Unclear if this data model could be all operational data, or
only the config false tree.  One problem with this is how you delete
some operational data?  If it is deleted from the control layer, why
is it also deleted from operational?

Also unclear how this layer would be populated.  If there is some data
hierarchy created in operational state, and someone wants to modify a
leaf deep down in the hierarchy, the hierarchy would have to be
created by the app, in order to set the leaf.





{{document:
    name ;
    ipr trust200902;
    category std;
    updates 6020;
    references operational-back.xml;
    title "Operational Data in NETCONF and YANG";
    contributor "author:Martin Bjorklund:Tail-f Systems:mbj@tail-f.com";
    contributor "author:Ladislav Lhotka:CZ.NIC:lhotka@nic.cz";
}}
