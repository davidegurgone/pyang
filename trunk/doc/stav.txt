# -*- outline -*-
#

This document defines the concept of operational state data in the
context of YANG and the Network Configuration Protocol (NETCONF).  It
updates RFC 6020 with rules for how to model the operational state,
and defines NETCONF operations to retreive and modify the operational
state.

* Introduction

** Terminology

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14, ^RFC2119^.

*** Terms

The following terms are defined in ^RFC6241^ and are not redefined
here:

- client
- datastore
- server

The following terms are defined in ^RFC6020^ and are not redefined
here:

- data model
- schema tree
- data node

The following terms are used within this document:

- operational state data: The data in the operational state datastore.

- operational state datastore: A conceptual data structure from which
  one can determine device state and behavior.

- configuration: A separate overlay/blueprint containing only data
  explicitly specified by clients.  The configuration's schema is
  congruent to a subtree of the operational state datastore's schema.
  The configuration may contain data that is currently not present in
  the operational state datastore (pre-provisioning).

* Objectives

- Develop a general model applicable not only to NETCONF but also
  to other approaches (RESTful, editable state data etc.).
- Develop a specific model for NETCONF and YANG.
- As little changes to NETCONF and YANG as possible.
- Clarification of the terms "operational state data" and "configuration".

* Problem Statement

** Modelling and Retrieving Operational State

The NETCONF operation <get> returns both device state data and the
running configuration.  Quite often, device parameters require a dual
representation, both as configuration and state data.

For instance, an IP address may be specified in an interface
configuration but, depending on other circumstances, this address may
not be used for that interface. In any case, an operator should be
able to obtain the addresses that are in operational use.

This implies that some state data must be modeled separately from the
configuration data, which leads to a certain amount of duplication in
data models. However, this approach has other drawbacks, too.  It is
counter-intuitive to data model designers, for whom configuration and
state parameters are closely related (see ^ex-if-list-1^ for an
example).  Data model duplication is error prone and leads to bigger
data models, that are more difficult to understand.  Further, there is
no formal information in the data model about the relationship between
the configuration and operational state data.

*** Example: Interface List @ex-if-list-1@

Suppose we want to model a list of interfaces.  We allow
pre-configuration, i.e., it is legal to configure an interface for
which there is currently no hardware present in the system.  In this
simple example, each interface has a name and a counter of the number
of packets received.  The counter is operational state data.

  list interface {
    key name;

    leaf name { ... }
    leaf in-packets {
      type yang:counter64;
      config false;
    }
    ...
  }

A particular device has hardware for two interfaces with names "eth0"
and "eth1".  In the configuration there is:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth2</name>
     ...
   </interface>

We can see this by doing <get-config>.

Operationally, however, the interfaces used are "eth0" and "eth1",
although "eth1" does not have any configuration and does not
send or receive packets.

How can an operator learn about the presence of "eth1"?  The <get>
operation returns the running configuration and state data together.
So, <get> will not show "eth1", since it is not present in the running
configuration.

With NETCONF as currently defined, the only alternative is to
duplicate the data model:

    list interface {
      key name;

      leaf name { ...}
      ...
    }

    list interface-oper {
      config false;
      key name;

      leaf name { ...}
      leaf in-packets { ... }
      ...
    }

** Modifying the Operational State

In some cases, it is useful for clients to directly modify the
operational state.  An example of this is the recent discussions
around an Interface to the Routing System (IRS), where a client needs
to modify the routing table, without storing routes in the
configuration.

With NETCONF as currently designed, the only way to do this is to
define separate operations.  This leads to another kind of data model
duplication, where every writable parameter is modelled both as state
data that can be retrieved using the <get> operation, and also as
input parameters to at least one rpc operation.

# [LL: My idea was that this would be treated as an alternative
# management interface that needn't necessarily be implemented with
# NETCONF means. SNMP is another example of such a parallel
# interface. We just have to make sure that the operational state
# datastore is able to work with multiple management interfaces but
# otherwise the is no need to define these interfaces in this draft.] 

*** Example: Routing Table Modification

Suppose we want to model IPv4 routing tables as operational state, and
we also want to be able to let a client modify this data.  We have to
do:

  list routing-table {
    config false;
    key name;

    leaf name { ... }
    list route {
      key id;

      leaf id { ... }
      leaf dest-prefix { ... }
      leaf next-hop { ... }
      ...
    }
  }
  
  rpc add-route {
    input {
      leaf routing-table-name { ... }
      leaf route-id { ... }
      leaf dest-prefix { ... }
      leaf dest-prefix { ... }
      leaf next-gop { ... }
    }
  }
  
  rpc delete-route {
    input {
      leaf routing-table-name { ... }
      leaf route-id { ... }
    }
  }

* Datastores

The fundamental idea of this document is to model operational state
data as an explicit data structure - the operational state datastore.
It is available to all management interfaces, which includes NETCONF
but also other interfaces such as SNMP.

Then, the NETCONF-specific "running" configuration datastore is
modeled as a separate overlay data structure whose layout is identical
to the subset of the operational state datastore that represents
configuration.
  
** Operational State Datastore

The operational state datastore consists of all parameters that
provide information about the instantaneous state of the device and
immediately influence the device's behavior.

The operational state datastore is a conceptual data structure.  This
means that implementations may choose any suitable representation of
the datastore, or even generate it dynamically upon request.

Operational state may be modified through one or more management
interfaces, or through the operation of network protocols.  All such
means of accessing and changing the operational state act conceptually
on the same data - the operational state datastore.  It means, for
instance, that any change caused by a network protocol is immediately
visible to all management interfaces.

Data nodes in the operational state datastore fall into two disjoint
categories:

- configuration/state
- state only

The former category includes data nodes that may be directly modified
by a management interface. In contrast, data nodes in the latter
category are read-only from the point of view of management
interfaces and can only only be modified by other means such as
network protocols.

In YANG terms, data nodes are tagged as configuration/state or state
via the "config" statement: the former category is "config true" while
the latter is "config false".

# [LL: These definitions are not NETCONF specific and make YANG data
# models potentially usable by other management interfaces.]     
#
# mbj: yes!

** Configuration Datastore

The configuration datastore is specific to the NETCONF management
interface. It can be thought of as a blueprint for the operational
datastore. Specifically, the schema for the configuration datastore is
congruent to a subtree of the schema for operational state datastore
containing only "config true" nodes.  In other words, every data node
in the configuration datastore schema has a corresponding data node
with the same name in the operational datastore schema, and the latter
data node is "config true".

Whenever a NETCONF client modifies the configuration datastore, the
server MUST immediately attempt to project the changes into the
operational state datastore. Most of the time, it simply means copying
the values in the configuration datastore to the corresponding
nodes in the operation state datastore.

However, the configuration datastore may contain data nodes that are
not projected into the operational state datastore. This happens in
the following three scenarios:

1. Pre-provisioned configuration prepared for hardware components that
   are not yet present in the device. See ^ex-if-list-1^ above.

2. Pre-provisioned configuration for components (hardware, protocols,
   etc.) that are intended to replace an existing item but are of a
   different type.

3. Parts of configuration that are momentarily not applicable.

In scenario 1, the server has to determine that the particular hardware
component is not present. In scenarios 2 and 3, a configuration data
node is ignored if a "when" condition that is specified for that node
or its ancestor evaluates to "false".

*** Example: Interface Replacement

This example is a use case for scenario 2. Consider the following data
model fragment:

  list interface {
    key "name";
    leaf name { ... };
    leaf type { ... };
    leaf local-name { ... };
    container ppp {
      when "../../type = 'PPP'";
      leaf flow-control { ... };
      ...
    }
    container ethernet {
      when "../../type = 'Ethernet'";
      leaf duplex { ... };
      ...
    }
  }

Assume a device initially has only a serial modem connection using PPP but a
migration to an Ethernet link is being prepared. The configuration may
then contain

  <interface>
    <name>uplink</name>
    <type>PPP</type>
    <local-name>ppp0</local-name>
    <ppp>
      <flow-control>crtscts</flow-control>
      ...
    </ppp>
    <ethernet>
      <duplex>full</duplex>
      ...
    </ethernet>
    ...
  </interface>

When this configuration is applied, the <ethernet> subtree is ignored
because its "when" condition evaluates to "false".

After the Ethernet uplink connection is established, an operator
changes the value of "type" to "Ethernet" and the value of
"local-name" to "eth0". Consequently, the <ethernet> part of the configuration is
applied and <ppp> now ignored.

*** Example: IP Address Assignment

This example is a use case for scenario 3. Consider the following data
model fragment:

  container dhcp {
    leaf enabled { ... };
    ...
  }
  container ipv4 {
    leaf ip {
      when "../../dhcp/enabled = 'false'";
      ...
    }
    ...
  }

Here is a configuration snippet:

  <dhcp>
    <enabled>true</enabled>
    ...
  </dhcp>
  <ipv4>
    <ip>192.0.2.1</ip>
  </ipv4>

Since the "when" condition under "ip" evaluates to "false", the
configured IP address 192.0.2.1 is not used. The node "ipv4/ip" in the
operational state datastore probably contains a different address
obtained from DHCP.  

* NETCONF Operations and Datastores

[Editor's Note: This section has to be expanded.]

This section explains the semantics of both existing and new NETCONF
operations in terms of how they affect the contents of the
configuration and operational state datastores.

Note that when <get-config> is used to retrieve a "config true" node,
the value stored in the configuration datastore is returned.  When
<get-operational> is used to retrieve the same node, the value
actually used by the device is returned.  This value may or may not be
the same as the value in the configuration datastore.

? Should there be a YANG statement 'operational <bool>' so that config
true nodes can be marked as not being part of the operational schema?

#[LL: We should first try to avoid it. If it turns out to be necessary,
#then perhaps a single node, e.g. "role" could be used, allowing three
#values: "config", "state" and "both".]

Nodes in the operational data store cannot be directly
modified using the standard NETCONF operations.  introduce oper:writable

** Constraints

This document updates section 8 of RFC 6020 with rules for the
operational state datastore.

[Editor's Note: Need to discuss these alternatives more, and document
one of them.]

There are a couple of design alternatives here:

*** Alternative A

No constraints ("must", "mandatory", "unique", "min-elements",
"max-elements") are enforced on the operational state datastore.  For
example, this means that a mandatory "config true" leaf does not have
to be present in the operational state datastore.

The problem with this approach is that there is no way to formally
define constraints on the OSD in the data model. This may be needed in
order to allow for coexistence of NETCONF with other management
interfaces that do not use the configuration datastore. Such
constraints can be specified in description statement though.

*** Alternative B

Change the definitions of mandatory, must, to work on osd instead of
config.

This would be a major backwards incompatible change to YANG, and it
would not be possible to define constraints on the configuration.

*** Alternative C

Introduce new YANG statements for OSD constraints, e.g. osd:must,
osd:mandatory etc.

The drawback with this is that it adds complexity.

* Protocol Operations

** <get-operational>

This document introduces a new operation <get-operational>, which is
used to retreive the operational state data from a device.  Note how
this operation differs from <get>, which is used to retrieve both the
running configuration and state data.

# [LL: WRT <get>: what happens if a config=true value is present in OSD
# but not in config? Should the OSD value be used? (I assume that
# configuration only merges all previous edits.)] 
#
# mbj: This is actually a bit unclear.  But this is why we should
# depreacte <get>, or at least ignore it...


<get-operational> takes the same parameters as <get>.

*** Example: Ethernet Duplex

As an example, consider a very simplified data model with a single
leaf for ethernet duplex:

  leaf duplex {
    type enumeration {
      enum "half";
      enum "full";
      enum "auto";
    }
    config true;
  }

# [LL: Here we have a case when the datatype is not the sam for config
# and OSD - "auto" can only appear in config. Should we address this
# somehow?]
#
# mbj: I think not.
  
Suppose a device with this data model implements the candidate
datastore.  The following is an example of data from such a device:

  get-config from candidate:

    <duplex>half</duplex>

  get-config from running:

    <duplex>auto</duplex>

  get-operational:

    <duplex>full</duplex>

In this example, the running configuration tells the device to
negotiate the duplex mode, and the current, operationally used, value
is "full".  At the same time, the (uncomitted) candidate configuration
contains the value "half".

** <edit-operational>

[Editor's note: NOT FINISHED - not clear if we need this]

Introduce edit-operational.  This modifies the subset of the
operational data tree that is also marked as writable.

Drawback: does not handle persistent operarational data.  If we have
persistent operational data, this has to be its own data store that
can be read and written.

A data model w/o the writable markers cannot be written to.  This is a
problem, since it is not obvious that the original designer though
about future use cases.  For example, our route tables are read-only.
Then IRS comes along and wants to write to this data.  Do we have to
update our spec?  Not good.  One option is for IRS to publish a
deviation data model that added the writable statement to our model.
This would be backwards compliant and good.  Even better would be if
they could publish a conformance statement in a module, w/o the need
for deviations.

## mbj: removed b/c (1) maybe we'll do edits, and (2) it describes
## stuff already in 6241.
# * NETCONF
#
# From the viewpoint of this document, the NETCONF protocol ^RFC6241^ is
# an instance of a management interface. It doesn't allow clients to
# directly modify the operational state datastore. Instead, a client
# edits the "running" configuration datastore which is then mapped by
# the NETCONF server to the operational state datastore.
#
# This section describes the conceptual model for the "running"
# configuration datastore and its relationship to the operational state
# datastore.
#
# Note that NETCONF servers may implement other optional datastores such
# as "candidate" or "startup". They serve different purposes but their
# common characteristic is that they do not interact directly with the
# operational state - their contents must first be copied to "running"
# in order to be applied. In the following, the term "configuration
# datastore" means the "running" configuration datastore.


## mbj: removed b/c it describes what's already described in 6020 and
## 6241.
# ** Applying the Contents of the Configuration Datastore
#
# + The new configuration must be syntactically valid (conform to a data
#   model schema) and the values of leaf nodes must have the correct
#   datatypes. If this is not satisfied, the edit is rejected.
#
# + The disabled parts of the operational state datastore are determined
#   by evaluating the XPath expressions in all 'when' statements. The
#   available tree for XPath evaluation are the new contents of the
#   configuration datastore superposed onto the operational state
#   datastore. [That is, for config=true data the values are taken from
#   the configuration datastore, for config=false data from the OS
#   datastore.]
#
#   It is not an error if the configuration datastore contains data
#   nodes that correspond to the disabled parts of the configuration
#   datastore. However, such data nodes MUST NOT be used in any way for
#   changing the operational state datastore.
#
# + Semantic constraints expressed by XPath expressions in 'must'
#   statements are validated. The available tree for XPath evaluation is
#   the same as in step 2, except that the disabled nodes (as determined
#   in step 2) are considered to be missing. If any of these XPath
#   expressions evaluate to "false" the edit is rejected.
#
# + Finally, the values of the configuration datastore that were
#   modified by the edit (except the disabled parts) are transferred to
#   the corresponding nodes in the operational state datastore.

* YANG Module @module@

RFC Ed.: update the date below with the date of RFC publication and
remove this note.

!! include-figure ietf-netconf-operational.yang extract-to="ietf-netconf-operational.yang"

* IANA Considerations @iana@

This document registers a URI in the IETF XML registry
^RFC3688^. Following the format in RFC 3688, the following
registration is requested to be made.

     URI: urn:ietf:params:xml:ns:yang:ietf-netconf-operational

     Registrant Contact: The NETMOD WG of the IETF.

     XML: N/A, the requested URI is an XML namespace.

This document registers a YANG module in the YANG Module Names
registry ^RFC6020^.

  name:         ietf-netconf-operational
  namespace:    urn:ietf:params:xml:ns:yang:ietf-netconf-operational
  prefix:       oper
  reference:    RFC XXXX

* Security Considerations

This document does not introduce any new security concerns in addition
to those specified in ^RFC6020^ and ^RFC6241^.

*! start-appendix

*** Example: Interface List @ex-if-list-2@

With the proposed solution, the interface list example from
^ex-if-list-2, can be solved with a single list:

  list interface {
    key name;

    leaf name { ... }
    leaf in-packets {
      type yang:counter64;
      config false;
    }
    ...
  }

The operation <get-operational> will return the interfaces available
on the device:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth1</name>
     ...
   </interface>

And <get-config> on running will return the configured interfaces,
just as before:

   <interface>
     <name>eth0</name>
     ...
   </interface>
   <interface>
     <name>eth2</name>
     ...
   </interface>

* Example: Ethernet Duplex

A typical problem is when the value space for the configuration data
is a superset of the value space for the operational state data.  An
example of this is Ethernet duplex, which can be configured as "half",
"full", or "auto", but the operationally used value is either "half"
or "full".  Without the definition of operational state in this
document, this would have to be modelled as two separate leafs:

  leaf duplex {
    type enumeration {
      enum "half";
      enum "full";
      enum "auto";
    }
  }
  
  leaf oper-duplex {
    type enumeration {
      enum "half";
      enum "full";
    }
  }

With the solution defined in this document, a single leaf is
sufficient:

  leaf duplex {
    type enumeration {
      enum "half";
      enum "full";
      enum "auto";
    }
  }

* Example: Admin vs. Oper State

Another common problem is when the value space for the configured data
is a subset of the operational state data.  An example is an
interface's desired state, and its operational state.  The desired
state can be "up" or "down", but the operational state can be "up",
"lower-layer-down", "testing", etc.

These kind of situations are still best modelled as two separate
leafs, one "admin-state" and one "oper-state".

{{document:
    name ;
    ipr trust200902;
    category std;
    updates 6020;
    references operational-back.xml;
    title "Operational Data in NETCONF and YANG";
    contributor "author:Martin Bjorklund:Tail-f Systems:mbj@tail-f.com";
    contributor "author:Ladislav Lhotka:CZ.NIC:lhotka@nic.cz";
}}
