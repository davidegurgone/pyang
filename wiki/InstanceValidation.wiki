#summary Validation of XML instances.

= Introduction =

[http://tools.ietf.org/html/rfc6110 RFC 6110] defines a mapping from YANG to standard [http://www.dsdl.org DSDL] schemas. Pyang's _dsdl_ plugin, together with several XSLT stylesheet that are also part of pyang distribution, fully implements the mapping procedure. The generated DSDL schemas can be used with generic off-the-shelf XML tools for both syntactic and semantic validation of XML instance documents.

This page explains the use of a shell script, _yang2dsdl_, which is also provided as a simple front end to the validation procedure. Developers that need more control should read about the hairy details in DSDLTechDetails.

= DSDL Schemas =

Let's apply the _yang2dsdl_ script to our data model, [TuringMachine turing-machine.yang], and generate a coordinated set of DSDL schemas:

{{{
$ yang2dsdl -t config turing-machine.yang
== Generating RELAX NG schema './turing-machine-config.rng'
Done.

== Generating Schematron schema './turing-machine-config.sch'
Done.

== Generating DSRL schema './turing-machine-config.dsrl'
Done.
}}}

As we can see from the output, three schemas are generated:

 * _RELAX NG_ schema (`turing-machine-config.rng`) describes the structure of the instance document (its grammar), and datatypes of leaf data nodes.

 * _Schematron_ schema (`turing-machine-config.sch`) represents semantic rules defined in the YANG data model.

 * _DSRL_ schema (`turing-machine-config.dsrl`) contains instructions that can be used for extending an instance XML document with default values.

The careful reader will notice that the script also created a fourth file, `turing-machine-gdefs-config.rng`, which is a part of the RELAX NG schema. 

The command-line option `-t` of _yang2dsdl_ defines the _target_ for the schemas. In this case, we instruct the script to generate schemas for the contents of a _configuration datastore_, i.e. configuration data only. Supported targets are:

<dl>
   <dt>*data*</dt>
   <dd>datastore contents (configuration and state data) encapsulated in `<nc:data>` document element;</dd>
   <dt>*config*</dt>
   <dd>configuration datastore contents encapsulated in `<nc:config>` document element;</dd>
   <dt>*get-reply*</dt>
   <dd>a complete NETCONF message containing a reply to `<nc:get>` operation;</dd>
   <dt>*get-config-reply*</dt>
   <dd>a complete NETCONF message containing a reply to `<nc:get-config>` operation;</dd>
   <dt>*rpc*</dt>
   <dd>RPC request;</dd>
   <dt>*rpc-reply*</dt>
   <dd>RPC reply;</dd>
   <dt>*notification*</dt>
   <dd>event notification.</dd>
</dl>

We will work with other targets later on in this tutorial.

= Creating an XML Instance =

Quite often, sample instance documents for testing and debugging purposes have to be written manually, in a text editor. Some people are fond of writing every single character in an XML or HTML document with their fingers. The rest of us, mere mortals, will want to reduce the drudgery by using an editor that provides some support for editing XML documents. 

An excellent choice is Emacs with James Clark's [http://www.thaiopensource.com/nxml-mode/ nXML mode]. With the RELAX NG schema we have just generated, we can turn it into a schema-aware editor with autocompletion and on-the-fly validation. We only need to convert the schema into the compact syntax, e.g. using [http://www.thaiopensource.com/relaxng/trang.html Trang]:

{{{
java -jar trang.jar -I rng -O rnc turing-machine-config.rng turing-machine-config.rnc
}}}

There are several way for telling nXML mode how to locate the right schema for the XML document being edited. The easiest option is to rely on file names. In our case it means that the name of the XML file should be `turing-machine-config.xml`.

Now that everything is in place, let's start editing, and assume we end up with following XML document, which is intended as a configuration for the Turing Machine:

<g:plusone size="medium"></g:plusone>

<wiki:comment>
Local Variables:
mode: fundamental
mode: visual-line
End:
</wiki:comment>
