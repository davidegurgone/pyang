#summary Validation of XML instances.

= Introduction =

[http://tools.ietf.org/html/rfc6110 RFC 6110] defines a mapping from YANG to standard [http://www.dsdl.org DSDL] schemas. Pyang's _dsdl_ plugin, together with several XSLT stylesheet that are also part of pyang distribution, fully implements the mapping procedure. The generated DSDL schemas can be used with generic off-the-shelf XML tools for both syntactic and semantic validation of XML instance documents.

This page explains the use of a shell script, _yang2dsdl_, which is also provided as a simple front end to the validation procedure. Developers that need more control should read about the hairy details in DSDLTechDetails.

= DSDL Schemas =

Let's apply the _yang2dsdl_ script to our data model, [TuringMachine turing-machine.yang], and generate a coordinated set of DSDL schemas:

<pre>
$ yang2dsdl -t config turing-machine.yang
== Generating RELAX NG schema './turing-machine-config.rng'
Done.

== Generating Schematron schema './turing-machine-config.sch'
Done.

== Generating DSRL schema './turing-machine-config.dsrl'
Done.
</pre>

As we can see from the output, three schemas are generated:

 * _RELAX NG_ schema (`turing-machine-config.rng`) describes the structure of the instance document (its grammar), and datatypes of leaf data nodes.

 * _Schematron_ schema (`turing-machine-config.sch`) represents semantic rules defined in the YANG data model.

 * _DSRL_ schema (`turing-machine-config.dsrl`) contains instructions that can be used for extending an instance XML document with default values.

The careful reader will notice that the script also created a fourth file, `turing-machine-gdefs-config.rng`, which is a part of the RELAX NG schema. 

The command-line option `-t` of _yang2dsdl_ defines the _target_ for the schemas. In this case, we instruct the script to generate schemas for the contents of a _configuration datastore_, i.e. configuration data only. Supported targets are:

<dl>
   <dt>*data*</dt>
   <dd>datastore contents (configuration and state data) encapsulated in `<nc:data>` document element;</dd>
   <dt>*config*</dt>
   <dd>configuration datastore contents encapsulated in `<nc:config>` document element;</dd>
   <dt>*get-reply*</dt>
   <dd>a complete NETCONF message containing a reply to `<nc:get>` operation;</dd>
   <dt>*get-config-reply*</dt>
   <dd>a complete NETCONF message containing a reply to `<nc:get-config>` operation;</dd>
   <dt>*rpc*</dt>
   <dd>RPC request;</dd>
   <dt>*rpc-reply*</dt>
   <dd>RPC reply;</dd>
   <dt>*notification*</dt>
   <dd>event notification.</dd>
</dl>

We will work with other targets later on in this tutorial.

= Creating an XML Instance =

Quite often, sample instance documents for testing and debugging purposes have to be written manually, in a text editor. Some people are fond of writing every single character in an XML or HTML document with their fingers. The rest of us, mere mortals, will want to reduce the drudgery by using an editor that provides some support for editing XML documents. 

An excellent choice is Emacs with James Clark's [http://www.thaiopensource.com/nxml-mode/ nXML mode]. With the RELAX NG schema we have just generated, we can turn it into a schema-aware editor with autocompletion and on-the-fly validation. We only need to convert the schema into the compact syntax, e.g. using [http://www.thaiopensource.com/relaxng/trang.html Trang]:

<pre>
java -jar trang.jar -I rng -O rnc turing-machine-config.rng turing-machine-config.rnc
</pre>

There are several way for telling nXML mode how to locate the right schema for the XML document being edited. The easiest option is to rely on file names. In our case it means that the name of the XML file should be `turing-machine-config.xml`.

Now that everything is in place, we can write our first configuration for the Turing Machine:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<!-- file: turing-machine-config.xml -->
<config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <turing-machine xmlns="http://example.net/turing-machine">
    <transition-function>
      <delta>
	<label>left summand</label>
	<input>
	  <state>0</state>
	  <symbol>1</symbol>
	</input>
	<output>
	  <head-move>right</head-move>
	</output>
      </delta>
      <delta>
	<label>separator</label>
	<input>
	  <state>0</state>
	  <symbol>0</symbol>
	</input>
	<output>
	  <state>1</state>
	  <symbol>1</symbol>
	  <head-move>right</head-move>
	</output>
      </delta>
      <delta>
	<label>right summand</label>
	<input>
	  <state>1</state>
	  <symbol>1</symbol>
	</input>
	<output>
	  <head-move>right</head-move>
	</output>
      </delta>
      <delta>
	<label>right end</label>
	<input>
	  <state>1</state>
	  <symbol/>
	</input>
	<output>
	  <state>2</state>
	  <head-move>left</head-move>
	</output>
      </delta>
      <delta>
	<label>write separator</label>
	<input>
	  <state>2</state>
	  <symbol>1</symbol>
	</input>
	<output>
	  <state>3</state>
	  <symbol>0</symbol>
	  <head-move>left</head-move>
	</output>
      </delta>
      <delta>
	<label>go home</label>
	<input>
	  <state>3</state>
	  <symbol>1</symbol>
	</input>
	<output>
	  <head-move>left</head-move>
	</output>
      </delta>
      <delta>
	<label>final step</label>
	<input>
	  <state>3</state>
	  <symbol/>
	</input>
	<output>
	  <state>4</state>
	  <head-move>right</head-move>
	</output>
      </delta>
    </transition-function>
  </turing-machine>
</config>
}}}

By the way, this “program” adds two numbers that are written on the tape in the unary notation and separated by the zero symbol.

The schemas for the `config` target expect `<config>` (in the NETCONF namespace) as the document element. This is because YANG allows for multiple roots of the data hierarchy, and so an extra wrapping element is needed in order to make sure that the document is well-formed XML.

We can now use _yang2dsdl_ again to verify that the above configuration is a valid instance of the data model:

<pre>
$ yang2dsdl -s -j -b turing-machine -t config -v turing-machine-config.xml
== Using pre-generated schemas

== Validating grammar and datatypes ...
turing-machine-config.xml validates.

== Adding default values... done.

== Validating semantic constraints ...
No errors found.
</pre>

Sure enough, everything is fine. The `-s` option indicates that we want to use pre-generated schemas, and then we also have to provide the `-b` (base name) and `-t` (target) options, so that the script is able to find the schemas. The `-j` option instructs the script to use [http://www.thaiopensource.com/relaxng/jing.html Jing] as the RELAX NG validator. By default, _xmllint_ from the [http://www.xmlsoft.org/ Libxml2] toolkit is used. While _xmllint_ is more common and also works, its error messages are sometimes rather incomprehensible.

Now, let's smuggle some bugs into the instance document. First, we change the value of the input state element in the first transition rule (`left summand`) from `0` to `zero`. This is a type error because the data model says the `state` leaf is `uint16`. Type errors are caught by the RELAX NG validator:

<pre>
$ yang2dsdl -s -j -b turing-machine -t config -v turing-machine-config.xml
== Using pre-generated schemas

== Validating grammar and datatypes ...
/Users/lhotka/sandbox/YANG/Turing/turing-machine-config.xml:9:23: error: character
content of element "state" invalid; must be an integer
</pre>

Next, we will return the value of `<state>` to the original correct value and introduce a new, more subtle error. We will create a new entry of the `delta` list with the following content:

{{{
<delta>
  <label>illegal</label>
  <input>
    <state>0</state>
    <symbol>0</symbol>
  </input>
  <output>
    <head-move>left</head-move>
  </output>
</delta>
}}}

See what happens:

<pre>
$ yang2dsdl -s -j -b turing-machine -t config -v turing-machine-config.xml
== Using pre-generated schemas

== Validating grammar and datatypes ...
turing-machine-config.xml validates.

== Adding default values... done.

== Validating semantic constraints ...
--- Validity error at "/nc:config/tm:turing-machine/tm:transition-function/tm:delta":
    Violated uniqueness for "tm:input/tm:state tm:input/tm:symbol"
</pre>

Right, the data model states that the input parameters `state` and `symbol` must be unique among the entries of the `delta` list:

{{{
unique "input/state input/symbol";
}}}

However, this semantic constraint is not satisfied because two entries, `separator` and `illegal`, now have identical input parameters.

As an exercise, try to introduce other errors to the instance document and run the same command again. 

= Validating RPC requests and replies =

Before starting the computation, we have to initialize the Turing Machine properly. This is easy because our data model defines a custom RPC method exactly for this purpose.

So, after installing the above configuration for adding two numbers, we maight want to test it and compute, say, 2 + 3. The following RPC request does the initialization job:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<!-- file: turing-machine-rpc.xml -->
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
     message-id="1">
  <initialize xmlns="http://example.net/turing-machine">
    <tape-content>110111</tape-content>
  </initialize>
</rpc>
}}}

The `<tape-content>` element specifies the initial contents of the tape, i.e. numbers 2 and 3 in the unary notation, separated with a zero.

We can validate this RPC message, too. This time, we will generate the schemas for RPC replies and perform the validation in one step:

<pre>
$ yang2dsdl -t rpc -v turing-machine-rpc.xml turing-machine.yang
== Generating RELAX NG schema './turing-machine-rpc.rng'
Done.

== Generating Schematron schema './turing-machine-rpc.sch'
Done.

== Generating DSRL schema './turing-machine-rpc.dsrl'
Done.

== Validating grammar and datatypes ...
turing-machine-rpc.xml validates

== Adding default values... done.

== Validating semantic constraints ...
No errors found.
</pre>

Note that this time the target is `rpc`.

After starting the computation with the other custom RPC method, `run`, we can wait until we receive the `halted` notification indicating that the Turing Machine is done. We can learn the result by sending a `get` request. The Turing Machine's NETCONF server should reply with the following message:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<!-- file: turing-machine-rpc-reply.xml -->
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
	   message-id="3">
  <data>
    <turing-machine xmlns="http://example.net/turing-machine">
      <state>4</state>
      <head-position>0</head-position>
      <tape>
	<cell>
	  <coord>0</coord>
	  <symbol>1</symbol>
	</cell>
	<cell>
	  <coord>1</coord>
	  <symbol>1</symbol>
	</cell>
	<cell>
	  <coord>2</coord>
	  <symbol>1</symbol>
	</cell>
	<cell>
	  <coord>3</coord>
	  <symbol>1</symbol>
	</cell>
	<cell>
	  <coord>4</coord>
	  <symbol>1</symbol>
	</cell>
	<cell>
	  <coord>5</coord>
	  <symbol>0</symbol>
	</cell>
      </tape>
      <transition-function>
	<delta>
	  <label>left summand</label>
	  <input>
	    <state>0</state>
	    <symbol>1</symbol>
	  </input>
	  <output>
	    <head-move>right</head-move>
	  </output>
	</delta>
	<delta>
	  <label>separator</label>
	  <input>
	    <state>0</state>
	    <symbol>0</symbol>
	  </input>
	  <output>
	    <state>1</state>
	    <symbol>1</symbol>
	    <head-move>right</head-move>
	  </output>
	</delta>
	<delta>
	  <label>right summand</label>
	  <input>
	    <state>1</state>
	    <symbol>1</symbol>
	  </input>
	  <output>
	    <head-move>right</head-move>
	  </output>
	</delta>
	<delta>
	  <label>right end</label>
	  <input>
	    <state>1</state>
	    <symbol/>
	  </input>
	  <output>
	    <state>2</state>
	    <head-move>left</head-move>
	  </output>
	</delta>
	<delta>
	  <label>write separator</label>
	  <input>
	    <state>2</state>
	    <symbol>1</symbol>
	  </input>
	  <output>
	    <state>3</state>
	    <symbol>0</symbol>
	    <head-move>left</head-move>
	  </output>
	</delta>
	<delta>
	  <label>go home</label>
	  <input>
	    <state>3</state>
	    <symbol>1</symbol>
	  </input>
	  <output>
	    <head-move>left</head-move>
	  </output>
	</delta>
	<delta>
	  <label>final step</label>
	  <input>
	    <state>3</state>
	    <symbol/>
	  </input>
	  <output>
	    <state>4</state>
	    <head-move>right</head-move>
	  </output>
	</delta>
      </transition-function>
    </turing-machine>
  </data>
</rpc-reply>
}}}

We can now read the result from the tape data, and we can also validate the `<get>` reply:

<pre>
$ yang2dsdl -t get-reply -v turing-machine-get-reply.xml turing-machine.yang 
== Generating RELAX NG schema './turing-machine-get-reply.rng'
Done.

== Generating Schematron schema './turing-machine-get-reply.sch'
Done.

== Generating DSRL schema './turing-machine-get-reply.dsrl'
Done.

== Validating grammar and datatypes ...
turing-machine-get-reply.xml validates

== Adding default values... done.

== Validating semantic constraints ...
No errors found.
</pre>

<g:plusone size="medium"></g:plusone>

<wiki:comment>
Local Variables:
mode: fundamental
mode: visual-line
End:
</wiki:comment>
