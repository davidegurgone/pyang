#summary DSDL mapping, schemas and validation.

= Introduction =

This page gives technical details about the mapping of YANG modules to DSDL schemas and instance validation. It is a recommended reading for developers who intend to perform validation in their code. A good knowledge of the concepts of XML schema languages, in particular RELAX NG and Schematron, is assumed.

= Mapping YANG to DSDL Schemas =

[http://tools.ietf.org/html/rfc6110 RFC 6110] defines the standard mapping of a YANG data model to [http://www.dsdl.org DSDL] schemas. That document, as well as its implementation in pyang, divide the mapping algorithm into two major steps:
 # Mapping a YANG data model to the _hybrid schema_.
 # Generating DSDL schemas (RELAX NG, DSRL and Schematron) from the hybrid schema.

== Hybrid Schema ==

The hybrid schema is an XML document which captures all aspects of the data model. It uses the RELAX NG syntax for defining grammatic and datatype constraints. However, it is _not_ a RELAX NG schema because, depending on the data model, it may contain schemas for multiple targets (document types). RELAX NG elements are annotated with additional information about semantic constraints and default values. Annotations are attributes or elements from the XML namespace with URI `urn:ietf:params:xml:ns:netmod:dsdl-annotations:1`.

In pyang, he hybrid schema is generated using the `dsdl` plugin, for example:

{{{
pyang -f dsdl -o turing-machine.dsdl turing-machine.yang
}}}

The output XML is unformatted, so a pretty-printer, such as `xmllint --format` might be handy for inspecting the hybrid schema.

== DSDL Schemas ==

From the hybrid schema, standard-compliant DSDL Schemas can be generated. In pyang, this second step is implemented via XSLT 1.0, using the following stylesheets (found in the `xslt` subdirectory):

 * `gen-relaxng.xsl` – generates the RELAX NG schema,
 * `gen-dsrl.xsl` – generates the DSRL schema,
 * `gen-schematron.xsl` – generates the Schematron schema.

The stylesheet generating RELAX NG actually has to be applied twice. The following example uses the ubiquitous _xsltproc_ tool, but other XSLT processors should work, too:
{{{
$ xsltproc -o turing-machine-gdefs-config.rng --stringparam target config \
> --stringparam gdefs-only 1 \
> $PYANG_XSLT_DIR/gen-relaxng.xsl turing-machine.dsdl
$ xsltproc -o turing-machine-config.rng --stringparam target config \
> $PYANG_XSLT_DIR/gen-relaxng.xsl turing-machine.dsdl
}}}

In the first invocation, with the `gdefs-only` parameter set to the value of `1`, the XSLT processor only extracts _global definitions_ (named patterns in RELAX NG terms). This step is necessary because these global definitions have to support the so-called “chameleon” design, in which a definition adopts the XML namespace of the grammar in which the definition is referenced (for a detailed explanation, see [http://books.xmlschemata.org/relaxng/relax-CHP-11-SECT-5.html Section 11.5] in E. van der Vlist: _RELAX NG_, O'Reilly, 2003).

The second invocation then generates the actual schema for the selected target (`config` in our example). In it, the sub-schema of each YANG module inhabits a second-level grammar, and each such grammar then includes the schema with global definitions that was generated in the first invocation.

Care has to be taken when selecting names of output files into which the schemas are written, so as to allow the main schema to locate the schema file with global definitions. The rules for naming the files is explained in the manual page _yang2dsdl (1)_.

The other two schemas, DSRL and Schematron, require only one invocation of a XSLT processor:
{{{
$ xsltproc -o turing-machine-config.dsrl --stringparam target config \
> $PYANG_XSLT_DIR/gen-dsrl.xsl turing-machine.dsdl 
$ xsltproc -o turing-machine-config.sch --stringparam target config \
> $PYANG_XSLT_DIR/gen-schematron.xsl turing-machine.dsdl
}}}

Note that the Turing Machine data model doesn't define any default values for configuration parameters, so the DSRL schema for the `config` target is empty.  

= Validation Procedure =

The procedure for validating instance XML documents or NETCONF messages against DSDL schemas is outlined in this picture:

https://pyang.googlecode.com/svn/trunk/doc/tutorial/validation.png

To demonstrate the individual steps, we will validate the contents of the configuration datastore from [InstanceValidation#Creating an XML Instance].

First of all, we have to validate the grammar and datatypes with a RELAX NG validator, such as _xmllint_:
{{{
$ xmllint --noout --relaxng turing-machine-config.rng turing-machine-config.xml
turing-machine-config.xml validates
}}}

Bear in mind that the type of the validated document must always match the target of the schema, in this case `config`.

= Implementing Validation on Devices =

TBD 

<g:plusone size="medium"></g:plusone>

<wiki:comment>
Local Variables:
mode: fundamental
mode: visual-line
End:
</wiki:comment>
